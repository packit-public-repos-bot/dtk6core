// SPDX-FileCopyrightText: 2024 UnionTech Software Technology Co., Ltd.
//
// SPDX-License-Identifier: LGPL-3.0-or-later

#include <QCoreApplication>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QJsonArray>
#include <QFile>
#include <QDebug>
#include <QCommandLineParser>
#include <QFileInfo>

// Converts a QJsonValue to a corresponding C++ code representation
static QString jsonValueToCppCode(const QJsonValue &value){
    if (value.isBool()) {
        return value.toBool() ? "true" : "false";
    } else if (value.isDouble()) {
        const auto variantValue = value.toVariant();
        if (variantValue.userType() == QVariant(static_cast<int>(1)).userType()) {
            return QString::number(value.toInt());
        } else if (variantValue.userType() == QVariant(static_cast<qint64>(1)).userType()) {
            return QString::number(variantValue.toLongLong());
        }

        return QString::number(value.toDouble());
    } else if (value.isString()) {
        return QString("QStringLiteral(\"%1\")").arg(value.toString());
    } else if (value.isNull()) {
        return "QVariant::fromValue(nullptr)";
    } else if (value.isArray()) {
        QStringList elements;
        const auto array = value.toArray();
        for (const QJsonValue &element : array) {
            elements << "QVariant(" + jsonValueToCppCode(element) + ")";
        }
        return "QList<QVariant>{" + elements.join(", ") + "}";
    } else if (value.isObject()) {
        QStringList elements;
        QJsonObject obj = value.toObject();
        for (auto it = obj.begin(); it != obj.end(); ++it) {
            elements << QString("{QStringLiteral(\"%1\"), QVariant(%2)}").arg(it.key(), jsonValueToCppCode(it.value()));
        }
        return "QVariantMap{" + elements.join(", ") + "}";
    } else {
        return "QVariant()";
    }
}

int main(int argc, char *argv[]) {
    QCoreApplication app(argc, argv);
    QCommandLineParser parser;
    parser.setApplicationDescription(QStringLiteral("DConfig to C++ class generator"));
    parser.addHelpOption();

    // Define command line options
    QCommandLineOption classNameOption(QStringList() << QStringLiteral("c") << QStringLiteral("class-name"),
                                       QStringLiteral("Name of the generated class"),
                                       QStringLiteral("className"));
    parser.addOption(classNameOption);

    QCommandLineOption sourceFileOption(QStringList() << QStringLiteral("o") << QStringLiteral("output"),
                                        QStringLiteral("Path to the output source(header only) file"),
                                        QStringLiteral("sourceFile"));
    parser.addOption(sourceFileOption);

    parser.addPositionalArgument(QStringLiteral("json-file"), QStringLiteral("Path to the input JSON file"));
    parser.process(app);

    const QStringList args = parser.positionalArguments();
    if (args.size() != 1) {
        parser.showHelp(-1);
    }

    QString className = parser.value(classNameOption);
    if (className.isEmpty()) {
        QString jsonFileName = QFileInfo(args.first()).completeBaseName();
        className = jsonFileName.replace('.', '_');
    }

    QString sourceFilePath = parser.value(sourceFileOption);
    if (sourceFilePath.isEmpty()) {
        sourceFilePath = className.toLower() + QStringLiteral(".hpp");
    }

    QFile file(args.first());
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning() << QStringLiteral("Failed to open file:") << args.first();
        return -1;
    }

    QByteArray data = file.readAll();
    QJsonDocument doc = QJsonDocument::fromJson(data);
    QJsonObject root = doc.object();

    // Check magic value
    if (root[QStringLiteral("magic")].toString() != QStringLiteral("dsg.config.meta")) {
        qWarning() << QStringLiteral("Invalid magic value in JSON file");
        return -1;
    }

    // Generate header and source files
    QFile headerFile(sourceFilePath);
    if (!headerFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << QStringLiteral("Failed to open file for writing:") << sourceFilePath;
        return -1;
    }

    QTextStream headerStream(&headerFile);

    // Extract version and add it as a comment in the generated code
    QString version = root[QStringLiteral("version")].toString();

    // Generate header and source file comments
    QString commandLineArgs = QCoreApplication::arguments().join(QStringLiteral(" "));
    QString generationTime = QDateTime::currentDateTime().toString(Qt::ISODate);

    QString headerComment = QString(
        QStringLiteral("/**\n"
        " * This file is generated by dconfig2cpp.\n"
        " * Command line arguments: %1\n"
        " * Generation time: %2\n"
        " * JSON file version: %3\n"
        " * \n"
        " * WARNING: DO NOT MODIFY THIS FILE MANUALLY.\n"
        " * If you need to change the content, please modify the dconfig2cpp tool.\n"
        " */\n\n")
    ).arg(commandLineArgs, generationTime, version);

    headerStream << headerComment;
    QJsonObject contents = root[QStringLiteral("contents")].toObject();

    // Write header file content
    headerStream << "#ifndef " << className.toUpper() << "_H\n";
    headerStream << "#define " << className.toUpper() << "_H\n\n";
    headerStream << "#include <QThread>\n";
    headerStream << "#include <QVariant>\n";
    headerStream << "#include <QDebug>\n";
    headerStream << "#include <QAtomicPointer>\n";
    headerStream << "#include <QAtomicInteger>\n";
    headerStream << "#include <DConfig>\n\n";
    headerStream << "class " << className << " : public QObject {\n";
    headerStream << "    Q_OBJECT\n\n";

    struct Property {
        QString typeName;
        QString propertyName;
        QString capitalizedPropertyName;
        QJsonValue defaultValue;
    };
    QList<Property> properties;

    // Iterate over JSON contents to extract properties
    for (auto it = contents.begin(); it != contents.end(); ++it) {
        QJsonObject obj = it.value().toObject();
        QString propertyName = it.key();
        QString typeName;
        const auto value = obj[QStringLiteral("value")];
        if (value.isBool()) {
            typeName = "bool";
        } else if (value.isArray()) {
            typeName = "QList<QVariant>";
        } else if (value.isObject()) {
            typeName = "QVariantMap";
        } else if (value.isDouble()) {
            const auto variantValue = value.toVariant();
            if (variantValue.userType() == QVariant(static_cast<int>(1)).userType()) {
                typeName = "int";
            } else if (variantValue.userType() == QVariant(static_cast<qint64>(1)).userType()) {
                typeName = "qint64";
            } else {
                typeName = "double";
            }
        } else if (value.isString()) {
            typeName = "QString";
        } else {
            typeName = "QVariant";
        }

        QString capitalizedPropertyName = propertyName;
        if (!capitalizedPropertyName.isEmpty() && capitalizedPropertyName[0].isLower()) {
            capitalizedPropertyName[0] = capitalizedPropertyName[0].toUpper();
        }

        properties.append(Property({
            typeName,
            propertyName,
            capitalizedPropertyName,
            obj[QStringLiteral("value")]
        }));

        headerStream << "    Q_PROPERTY(" << typeName << " " << propertyName << " READ " << propertyName 
                     << " WRITE set" << capitalizedPropertyName << " NOTIFY " << propertyName << "Changed)\n";
    }
    headerStream << "public:\n";

    // Helper lambda to generate constructor code
    auto genericConstructor = [&] (const QString &dconfigCreateArguments) {
        headerStream << "\n        : QObject(parent) {\n" << R"(
        if (!thread->isRunning()) {
            qWarning() << QStringLiteral("Warning: The provided thread is not running.");
        }
        Q_ASSERT(QThread::currentThread() != thread);
        auto worker = new QObject();
        worker->moveToThread(thread);
        QMetaObject::invokeMethod(worker, [=]() {
            auto config = DTK_CORE_NAMESPACE::DConfig::create()" << dconfigCreateArguments << R"(, nullptr);
            if (!config) {
                qWarning() << QStringLiteral("Failed to create DConfig instance.");
                worker->deleteLater();
                return;
            }
            config->moveToThread(QThread::currentThread());
            initialize(config);
            worker->deleteLater();
        });
    }
)";
    };

    // Generate constructors
    headerStream << "    explicit " << className << "(QThread *thread, const QString &appId, const QString &name, const QString &subpath, QObject *parent = nullptr)";
    genericConstructor(QStringLiteral("appId, name, subpath"));
    headerStream << "    explicit " << className << "(QThread *thread, DTK_CORE_NAMESPACE::DConfigBackend *backend, const QString &appId, const QString &name, const QString &subpath, QObject *parent = nullptr)";
    genericConstructor(QStringLiteral("backend, appId, name, subpath"));
    headerStream << "    explicit " << className << "(QThread *thread, const QString &name, const QString &subpath, QObject *parent = nullptr)";
    genericConstructor(QStringLiteral("name, subpath"));
    headerStream << "    explicit " << className << "(QThread *thread, DTK_CORE_NAMESPACE::DConfigBackend *backend, const QString &name, const QString &subpath, QObject *parent = nullptr)";
    genericConstructor(QStringLiteral("backend, name, subpath"));

    // Destructor
    headerStream << "    ~" << className << R"(() {
        if (m_config.loadRelaxed()) {
            m_config.loadRelaxed()->deleteLater();
        }
    }

)";

    // Generate property getter and setter methods
    for (int i = 0; i < properties.size(); ++i) {
        const Property &property = properties[i];
        headerStream << "    " << property.typeName << " " << property.propertyName << "() const {\n"
                     << "        return p_" << property.propertyName << ";\n    }\n";
        headerStream << "    void set" << property.capitalizedPropertyName << "(const " << property.typeName << " &value) {\n"
                     << "        auto oldValue = p_" << property.propertyName << ";\n"
                     << "        p_" << property.propertyName << " = value;\n"
                     << "        markPropertySet(" << i << ");\n"
                     << "        if (auto config = m_config.loadRelaxed()) {\n"
                     << "            QMetaObject::invokeMethod(config, [this, value]() {\n"
                     << "                m_config.loadRelaxed()->setValue(QStringLiteral(\"" << property.propertyName << "\"), value);\n"
                     << "            });\n"
                     << "        }\n"
                     << "        if (p_" << property.propertyName << " != oldValue) {\n"
                     << "            Q_EMIT " << property.propertyName << "Changed();\n"
                     << "        }\n"
                     << "    }\n";
    }

    // Generate signals for property changes
    headerStream << "Q_SIGNALS:\n";
    for (const Property &property : std::as_const(properties)) {
        headerStream << "    void " << property.propertyName << "Changed();\n";
    }

    // Generate private methods and members
    headerStream << "private:\n";
    headerStream << "    void initialize(DTK_CORE_NAMESPACE::DConfig *config) {\n";
    headerStream << "        Q_ASSERT(!m_config.loadRelaxed());\n        m_config.storeRelaxed(config);\n";
    for (int i = 0; i < properties.size(); ++i) {
        const Property &property = properties[i];
        headerStream << "        if (testPropertySet(" << i << ")) {\n";
        headerStream << "            config->setValue(QStringLiteral(\"" << property.propertyName << "\"), QVariant::fromValue(p_" << property.propertyName << "));\n";
        headerStream << "        } else {\n";
        headerStream << "            updateValue(QStringLiteral(\"" << property.propertyName << "\"), QVariant::fromValue(p_" << property.propertyName << "));\n";
        headerStream << "        }\n";
    }
    headerStream << R"(
        connect(config, &DTK_CORE_NAMESPACE::DConfig::valueChanged, this, [this](const QString &key) {
            updateValue(key);
        }, Qt::DirectConnection);
    }
    void updateValue(const QString &key, const QVariant &fallback = QVariant()) {
        Q_ASSERT(QThread::currentThread() == m_config.loadRelaxed()->thread());
        const QVariant &value = m_config.loadRelaxed()->value(key, fallback);
)";
    for (const Property &property : std::as_const(properties)) {
        headerStream << "        if (key == QStringLiteral(\"" << property.propertyName << "\")) {\n";
        headerStream << "            auto newValue = qvariant_cast<" << property.typeName << ">(value);\n";
        headerStream << "            QMetaObject::invokeMethod(this, [this, newValue]() {\n";
        headerStream << "                if (p_" << property.propertyName << " != newValue) {\n";
        headerStream << "                    p_" << property.propertyName << " = newValue;\n";
        headerStream << "                    Q_EMIT " << property.propertyName << "Changed();\n";
        headerStream << "                }\n";
        headerStream << "            });\n";
        headerStream << "            return;\n";
        headerStream << "        }\n";
    }
    headerStream << "    }\n";

    // Mark property as set
    headerStream << "    inline void markPropertySet(const int index) {\n";
    for (int i = 0; i <= (properties.size()) / 32; ++i) {
        headerStream << "        if (index < " << (i + 1) * 32 << ") {\n";
        headerStream << "            m_propertySetStatus" << QString::number(i) << ".fetchAndOrOrdered(1 << (index - " << i * 32 << "));\n";
        headerStream << "            return;\n        }\n";
    }
    headerStream << "        Q_UNREACHABLE();\n    }\n";

    // Test if property is set
    headerStream << "    inline bool testPropertySet(const int index) const {\n";
    for (int i = 0; i <= (properties.size()) / 32; ++i) {
        headerStream << "        if (index < " << (i + 1) * 32 << ") {\n";
        headerStream << "            return (m_propertySetStatus" << QString::number(i) << ".loadRelaxed() & (1 << (index - " << i * 32 << ")));\n";
        headerStream << "        }\n";
    }
    headerStream << "        Q_UNREACHABLE();\n    }\n";

    // Member variables
    headerStream << "    QAtomicPointer<DTK_CORE_NAMESPACE::DConfig> m_config = nullptr;\n";

    // Property variables
    for (const Property &property : std::as_const(properties)) {
        if (property.typeName == "int" || property.typeName == "qint64") {
            headerStream << "    // Note: If you expect a double type, add 'e' to the number in the JSON value field, e.g., \"value\": 1.0e, not just 1.0\n";
        }
        headerStream << "    " << property.typeName << " p_" << property.propertyName << " { ";
        headerStream << jsonValueToCppCode(property.defaultValue) << " };\n";
    }

    // Property set status variables
    for (int i = 0; i <= (properties.size()) / 32; ++i) {
        headerStream << "    QAtomicInteger<quint32> m_propertySetStatus" << QString::number(i) << " = 0;\n";
    }
    headerStream << "};\n\n";
    headerStream << "#endif // " << className.toUpper() << "_H\n";

    return 0;
}
